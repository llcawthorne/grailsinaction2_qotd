


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: PageFragmentCachingFilter</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">grails.plugin.cache.web.filter</a> ]
</div>

<h1>Coverage Summary for Class: PageFragmentCachingFilter (grails.plugin.cache.web.filter)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">PageFragmentCachingFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 351)
  </span>
</td>
</tr>
  <tr>
    <td class="name">PageFragmentCachingFilter$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PageFragmentCachingFilter$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PageFragmentCachingFilter$CacheStatus</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 358)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/* Copyright 2012-2013 SpringSource.
<i>2</i>&nbsp; *
<i>3</i>&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<i>4</i>&nbsp; * you may not use this file except in compliance with the License.
<i>5</i>&nbsp; * You may obtain a copy of the License at
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
<i>8</i>&nbsp; *
<i>9</i>&nbsp; * Unless required by applicable law or agreed to in writing, software
<i>10</i>&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<i>11</i>&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<i>12</i>&nbsp; * See the License for the specific language governing permissions and
<i>13</i>&nbsp; * limitations under the License.
<i>14</i>&nbsp; */
<i>15</i>&nbsp;package grails.plugin.cache.web.filter;
<i>16</i>&nbsp;
<i>17</i>&nbsp;import grails.plugin.cache.GrailsAnnotationCacheOperationSource;
<i>18</i>&nbsp;import grails.plugin.cache.SerializableByteArrayOutputStream;
<i>19</i>&nbsp;import grails.plugin.cache.Timer;
<i>20</i>&nbsp;import grails.plugin.cache.web.ContentCacheParameters;
<i>21</i>&nbsp;import grails.plugin.cache.web.GenericResponseWrapper;
<i>22</i>&nbsp;import grails.plugin.cache.web.Header;
<i>23</i>&nbsp;import grails.plugin.cache.web.PageInfo;
<i>24</i>&nbsp;import grails.plugin.cache.web.SerializableCookie;
<i>25</i>&nbsp;import grails.util.GrailsNameUtils;
<i>26</i>&nbsp;
<i>27</i>&nbsp;import java.io.IOException;
<i>28</i>&nbsp;import java.io.Serializable;
<i>29</i>&nbsp;import java.lang.reflect.Method;
<i>30</i>&nbsp;import java.util.ArrayList;
<i>31</i>&nbsp;import java.util.Collection;
<i>32</i>&nbsp;import java.util.Enumeration;
<i>33</i>&nbsp;import java.util.HashMap;
<i>34</i>&nbsp;import java.util.LinkedHashMap;
<i>35</i>&nbsp;import java.util.List;
<i>36</i>&nbsp;import java.util.Map;
<i>37</i>&nbsp;import java.util.Set;
<i>38</i>&nbsp;import java.util.Stack;
<i>39</i>&nbsp;import java.util.TreeSet;
<i>40</i>&nbsp;
<i>41</i>&nbsp;import javax.servlet.FilterChain;
<i>42</i>&nbsp;import javax.servlet.ServletException;
<i>43</i>&nbsp;import javax.servlet.http.HttpServletRequest;
<i>44</i>&nbsp;import javax.servlet.http.HttpServletResponse;
<i>45</i>&nbsp;
<i>46</i>&nbsp;import org.codehaus.groovy.grails.plugins.web.api.RequestMimeTypesApi;
<i>47</i>&nbsp;import org.codehaus.groovy.grails.web.servlet.GrailsApplicationAttributes;
<i>48</i>&nbsp;import org.codehaus.groovy.grails.web.servlet.HttpHeaders;
<i>49</i>&nbsp;import org.codehaus.groovy.grails.web.servlet.WrappedResponseHolder;
<i>50</i>&nbsp;import org.codehaus.groovy.grails.web.servlet.mvc.GrailsParameterMap;
<i>51</i>&nbsp;import org.codehaus.groovy.grails.web.servlet.mvc.GrailsWebRequest;
<i>52</i>&nbsp;import org.codehaus.groovy.grails.web.util.WebUtils;
<i>53</i>&nbsp;import org.springframework.aop.framework.AopProxyUtils;
<i>54</i>&nbsp;import org.springframework.cache.Cache;
<i>55</i>&nbsp;import org.springframework.cache.Cache.ValueWrapper;
<i>56</i>&nbsp;import org.springframework.cache.interceptor.CacheEvictOperation;
<i>57</i>&nbsp;import org.springframework.cache.interceptor.CacheOperation;
<i>58</i>&nbsp;import org.springframework.cache.interceptor.CachePutOperation;
<i>59</i>&nbsp;import org.springframework.cache.interceptor.CacheableOperation;
<i>60</i>&nbsp;import org.springframework.core.LocalVariableTableParameterNameDiscoverer;
<i>61</i>&nbsp;import org.springframework.core.ParameterNameDiscoverer;
<i>62</i>&nbsp;import org.springframework.util.Assert;
<i>63</i>&nbsp;import org.springframework.util.ClassUtils;
<i>64</i>&nbsp;import org.springframework.util.CollectionUtils;
<i>65</i>&nbsp;import org.springframework.util.ReflectionUtils;
<i>66</i>&nbsp;import org.springframework.util.StringUtils;
<i>67</i>&nbsp;import org.springframework.web.context.request.RequestContextHolder;
<i>68</i>&nbsp;
<i>69</i>&nbsp;/**
<i>70</i>&nbsp; * A simple page fragment {@link CachingFilter} suitable for most uses.
<i>71</i>&nbsp; * &lt;p/&gt;
<i>72</i>&nbsp; * The meaning of &lt;i&gt;page fragment&lt;/i&gt; is:
<i>73</i>&nbsp; * &lt;ul&gt;
<i>74</i>&nbsp; * &lt;li&gt;An include into an outer page.
<i>75</i>&nbsp; * &lt;li&gt;A content type suitable for suitable for inclusion into the outer page.
<i>76</i>&nbsp; * e.g. text or text/html
<i>77</i>&nbsp; * &lt;/ul&gt;
<i>78</i>&nbsp; * For full page see {@link SimplePageCachingFilter}.
<i>79</i>&nbsp; * &lt;h3&gt;Keys&lt;/h3&gt; Pages are cached based on their key. The key for this cache is
<i>80</i>&nbsp; * the URI followed by the query string. An example is
<i>81</i>&nbsp; * &lt;code&gt;/admin/SomePage.jsp?id=1234&amp;name=Beagle&lt;/code&gt;.
<i>82</i>&nbsp; * &lt;p/&gt;
<i>83</i>&nbsp; * This key technique is suitable for a wide range of uses. It is independent of
<i>84</i>&nbsp; * hostname and port number, so will work well in situations where there are
<i>85</i>&nbsp; * multiple domains which get the same content, or where users access based on
<i>86</i>&nbsp; * different port numbers.
<i>87</i>&nbsp; * &lt;p/&gt;
<i>88</i>&nbsp; * A problem can occur with tracking software, where unique ids are inserted
<i>89</i>&nbsp; * into request query strings. Because each request generates a unique key,
<i>90</i>&nbsp; * there will never be a cache hit. For these situations it is better to parse
<i>91</i>&nbsp; * the request parameters and override
<i>92</i>&nbsp; * {@link #calculateKey(javax.servlet.http.HttpServletRequest)} with an
<i>93</i>&nbsp; * implementation that takes account of only the significant ones.
<i>94</i>&nbsp; * &lt;h3&gt;Configuring Caching with ehcache&lt;/h3&gt; A cache entry in ehcache.xml should
<i>95</i>&nbsp; * be configured with the name {@link #NAME}.
<i>96</i>&nbsp; * &lt;p/&gt;
<i>97</i>&nbsp; * Cache attributes including expiry are configured per cache name. To specify a
<i>98</i>&nbsp; * different behaviour simply subclass, specify a new name and create a separate
<i>99</i>&nbsp; * cache entry for it.
<i>100</i>&nbsp; * &lt;h3&gt;Gzipping&lt;/h3&gt; Page fragments should never be gzipped.
<i>101</i>&nbsp; * &lt;p/&gt;
<i>102</i>&nbsp; * Page fragments are stored in the cache ungzipped.
<i>103</i>&nbsp; *
<i>104</i>&nbsp; * Based on net.sf.ehcache.constructs.web.filter.SimplePageFragmentCachingFilter,
<i>105</i>&nbsp; * grails.plugin.springcache.web.GrailsFragmentCachingFilter, and
<i>106</i>&nbsp; * org.springframework.cache.interceptor.CacheAspectSupport
<i>107</i>&nbsp; *
<i>108</i>&nbsp; * @author Greg Luck
<i>109</i>&nbsp; * @author Rob Fletcher
<i>110</i>&nbsp; * @author Costin Leau
<i>111</i>&nbsp; * @author Juergen Hoeller
<i>112</i>&nbsp; * @author Chris Beams
<i>113</i>&nbsp; * @author Burt Beckwith
<i>114</i>&nbsp; */
<b class="nc"><i>115</i>&nbsp;public abstract class PageFragmentCachingFilter extends AbstractFilter {</b>
<i>116</i>&nbsp;
<i>117</i>&nbsp;	public static final String X_CACHED = &quot;X-Grails-Cached&quot;;
<i>118</i>&nbsp;
<i>119</i>&nbsp;	protected static final String CACHEABLE = &quot;cacheable&quot;;
<i>120</i>&nbsp;	protected static final String UPDATE = &quot;cacheupdate&quot;;
<i>121</i>&nbsp;	protected static final String EVICT = &quot;cacheevict&quot;;
<i>122</i>&nbsp;
<i>123</i>&nbsp;	// TODO share with ExpressionEvaluator
<b class="nc"><i>124</i>&nbsp;	protected ParameterNameDiscoverer paramNameDiscoverer = new LocalVariableTableParameterNameDiscoverer();</b>
<i>125</i>&nbsp;
<i>126</i>&nbsp;	@SuppressWarnings(&quot;unchecked&quot;)
<b class="nc"><i>127</i>&nbsp;	protected static final Map&lt;Class&lt;?&gt;, String&gt; TYPE_TO_CONVERSION_METHOD_NAME = grails.util.CollectionUtils.&lt;Class&lt;?&gt;, String&gt;newMap(</b>
<i>128</i>&nbsp;			Boolean.class,   &quot;boolean&quot;,
<i>129</i>&nbsp;			Byte.class,      &quot;byte&quot;,
<i>130</i>&nbsp;			Character.class, &quot;char&quot;,
<i>131</i>&nbsp;			Double.class,    &quot;double&quot;,
<i>132</i>&nbsp;			Float.class,     &quot;float&quot;,
<i>133</i>&nbsp;			Integer.class,   &quot;int&quot;,
<i>134</i>&nbsp;			Long.class,      &quot;long&quot;,
<i>135</i>&nbsp;			Short.class,     &quot;short&quot;);
<b class="nc"><i>136</i>&nbsp;	protected static List&lt;Class&lt;?&gt;&gt; PRIMITIVE_CLASSES = grails.util.CollectionUtils.&lt;Class&lt;?&gt;&gt;newList(</b>
<i>137</i>&nbsp;			boolean.class,
<i>138</i>&nbsp;			byte.class,
<i>139</i>&nbsp;			char.class,
<i>140</i>&nbsp;			double.class,
<i>141</i>&nbsp;			float.class,
<i>142</i>&nbsp;			int.class,
<i>143</i>&nbsp;			long.class,
<i>144</i>&nbsp;			short.class);
<b class="nc"><i>145</i>&nbsp;	protected static final Map&lt;String, Method&gt; PARAMS_METHODS = new HashMap&lt;String, Method&gt;();</b>
<i>146</i>&nbsp;	static {
<b class="nc"><i>147</i>&nbsp;		for (String typeName : TYPE_TO_CONVERSION_METHOD_NAME.values()) {</b>
<b class="nc"><i>148</i>&nbsp;			String methodName = GrailsNameUtils.getGetterName(typeName);</b>
<b class="nc"><i>149</i>&nbsp;			Method method = ClassUtils.getMethod(GrailsParameterMap.class, methodName, String.class);</b>
<b class="nc"><i>150</i>&nbsp;			PARAMS_METHODS.put(typeName, method);</b>
<b class="nc"><i>151</i>&nbsp;		}</b>
<i>152</i>&nbsp;	}
<i>153</i>&nbsp;
<i>154</i>&nbsp;	protected GrailsAnnotationCacheOperationSource cacheOperationSource;
<i>155</i>&nbsp;
<b class="nc"><i>156</i>&nbsp;	protected final ThreadLocal&lt;Stack&lt;ContentCacheParameters&gt;&gt; contextHolder = new ThreadLocal&lt;Stack&lt;ContentCacheParameters&gt;&gt;() {</b>
<i>157</i>&nbsp;		@Override
<i>158</i>&nbsp;		protected Stack&lt;ContentCacheParameters&gt; initialValue() {
<b class="nc"><i>159</i>&nbsp;			return new Stack&lt;ContentCacheParameters&gt;();</b>
<i>160</i>&nbsp;		}
<i>161</i>&nbsp;	};
<i>162</i>&nbsp;
<i>163</i>&nbsp;	protected ExpressionEvaluator expressionEvaluator;
<i>164</i>&nbsp;	protected WebKeyGenerator keyGenerator;
<i>165</i>&nbsp;
<i>166</i>&nbsp;	@Override
<i>167</i>&nbsp;	protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws Exception {
<i>168</i>&nbsp;// TODO need blocking cache stuff from CachingFilter
<b class="nc"><i>169</i>&nbsp;		initContext();</b>
<i>170</i>&nbsp;
<i>171</i>&nbsp;		try {
<i>172</i>&nbsp;
<b class="nc"><i>173</i>&nbsp;			Object controller = lookupController(getContext().getControllerClass());</b>
<b class="nc"><i>174</i>&nbsp;			if (controller == null) {</b>
<b class="nc"><i>175</i>&nbsp;				log.debug(&quot;Not a controller request {}:{} {}&quot;,</b>
<i>176</i>&nbsp;						new Object[] { request.getMethod(), request.getRequestURI(), getContext() });
<b class="nc"><i>177</i>&nbsp;				chain.doFilter(request, response);</b>
<i>178</i>&nbsp;				return;
<i>179</i>&nbsp;			}
<i>180</i>&nbsp;
<b class="nc"><i>181</i>&nbsp;			Class&lt;?&gt; controllerClass = AopProxyUtils.ultimateTargetClass(controller);</b>
<b class="nc"><i>182</i>&nbsp;			if (controllerClass == null) {</b>
<b class="nc"><i>183</i>&nbsp;				controllerClass = controller.getClass();</b>
<i>184</i>&nbsp;			}
<b class="nc"><i>185</i>&nbsp;			Method method = getContext().getMethod();</b>
<b class="nc"><i>186</i>&nbsp;			if (method == null) {</b>
<b class="nc"><i>187</i>&nbsp;				log.debug(&quot;No cacheable method found for {}:{} {}&quot;,</b>
<i>188</i>&nbsp;						new Object[] { request.getMethod(), request.getRequestURI(), getContext() });
<b class="nc"><i>189</i>&nbsp;				chain.doFilter(request, response);</b>
<i>190</i>&nbsp;				return;
<i>191</i>&nbsp;			}
<b class="nc"><i>192</i>&nbsp;			Collection&lt;CacheOperation&gt; cacheOperations = cacheOperationSource.getCacheOperations(</b>
<i>193</i>&nbsp;					method, controllerClass, true);
<i>194</i>&nbsp;
<b class="nc"><i>195</i>&nbsp;			if (CollectionUtils.isEmpty(cacheOperations)) {</b>
<b class="nc"><i>196</i>&nbsp;				log.debug(&quot;No cacheable annotation found for {}:{} {}&quot;,</b>
<i>197</i>&nbsp;						new Object[] { request.getMethod(), request.getRequestURI(), getContext() });
<b class="nc"><i>198</i>&nbsp;				chain.doFilter(request, response);</b>
<i>199</i>&nbsp;				return;
<i>200</i>&nbsp;			}
<i>201</i>&nbsp;
<b class="nc"><i>202</i>&nbsp;			Map&lt;String, Collection&lt;CacheOperationContext&gt;&gt; operationsByType = createOperationContext(</b>
<i>203</i>&nbsp;					cacheOperations, method, controllerClass, request);
<i>204</i>&nbsp;
<i>205</i>&nbsp;			// start with evictions
<b class="nc"><i>206</i>&nbsp;			if (inspectBeforeCacheEvicts(operationsByType.get(EVICT))) {</b>
<b class="nc"><i>207</i>&nbsp;				chain.doFilter(request, response);</b>
<i>208</i>&nbsp;				return;
<i>209</i>&nbsp;			}
<i>210</i>&nbsp;
<i>211</i>&nbsp;			// follow up with cacheable
<b class="nc"><i>212</i>&nbsp;			CacheStatus status = inspectCacheables(operationsByType.get(CACHEABLE));</b>
<i>213</i>&nbsp;
<b class="nc"><i>214</i>&nbsp;			Map&lt;CacheOperationContext, Object&gt; updates = inspectCacheUpdates(operationsByType.get(UPDATE));</b>
<i>215</i>&nbsp;
<b class="nc"><i>216</i>&nbsp;			if (status != null) {</b>
<b class="nc"><i>217</i>&nbsp;				if (status.updateRequired) {</b>
<b class="nc"><i>218</i>&nbsp;					updates.putAll(status.updates);</b>
<i>219</i>&nbsp;				}
<i>220</i>&nbsp;				// render cached response
<i>221</i>&nbsp;				else {
<b class="nc"><i>222</i>&nbsp;					logRequestDetails(request, getContext(), &quot;Caching enabled for request&quot;);</b>
<b class="nc"><i>223</i>&nbsp;					PageInfo pageInfo = buildCachedPageInfo(request, response, status);</b>
<b class="nc"><i>224</i>&nbsp;					writeResponse(request, response, pageInfo);</b>
<i>225</i>&nbsp;					return;
<i>226</i>&nbsp;				}
<i>227</i>&nbsp;			}
<i>228</i>&nbsp;
<b class="nc"><i>229</i>&nbsp;			logRequestDetails(request, getContext(), &quot;Caching enabled for request&quot;);</b>
<b class="nc"><i>230</i>&nbsp;			PageInfo pageInfo = buildNewPageInfo(request, response, chain, status, operationsByType);</b>
<b class="nc"><i>231</i>&nbsp;			writeResponse(request, response, pageInfo);</b>
<i>232</i>&nbsp;
<b class="nc"><i>233</i>&nbsp;			inspectAfterCacheEvicts(operationsByType.get(EVICT));</b>
<i>234</i>&nbsp;
<b class="nc"><i>235</i>&nbsp;			if (!updates.isEmpty()) {</b>
<b class="nc"><i>236</i>&nbsp;				Collection&lt;Cache&gt; caches = new ArrayList&lt;Cache&gt;();</b>
<b class="nc"><i>237</i>&nbsp;				for (Map.Entry&lt;CacheOperationContext, Object&gt; entry : updates.entrySet()) {</b>
<b class="nc"><i>238</i>&nbsp;					for (Cache cache : entry.getKey().getCaches()) {</b>
<b class="nc"><i>239</i>&nbsp;						caches.add(cache);</b>
<b class="nc"><i>240</i>&nbsp;					}</b>
<b class="nc"><i>241</i>&nbsp;				}</b>
<b class="nc"><i>242</i>&nbsp;				update(caches, pageInfo, status, calculateKey(request));</b>
<i>243</i>&nbsp;			}
<i>244</i>&nbsp;		}
<i>245</i>&nbsp;		finally {
<b class="nc"><i>246</i>&nbsp;			destroyContext();</b>
<b class="nc"><i>247</i>&nbsp;		}</b>
<i>248</i>&nbsp;	}
<i>249</i>&nbsp;
<i>250</i>&nbsp;	protected PageInfo buildNewPageInfo(HttpServletRequest request, HttpServletResponse response,
<i>251</i>&nbsp;			FilterChain chain, CacheStatus cacheStatus,
<i>252</i>&nbsp;			Map&lt;String, Collection&lt;CacheOperationContext&gt;&gt; operationsByType) throws Exception {
<i>253</i>&nbsp;
<b class="nc"><i>254</i>&nbsp;		Timer timer = new Timer(getCachedUri(request));</b>
<b class="nc"><i>255</i>&nbsp;		timer.start();</b>
<i>256</i>&nbsp;
<b class="nc"><i>257</i>&nbsp;		String key = calculateKey(request);</b>
<i>258</i>&nbsp;		PageInfo pageInfo;
<i>259</i>&nbsp;		try {
<i>260</i>&nbsp;			// Page is not cached - build the response, cache it, and send to client
<b class="nc"><i>261</i>&nbsp;			pageInfo = buildPage(request, response, chain);</b>
<b class="nc"><i>262</i>&nbsp;			if (pageInfo.isOk()) {</b>
<b class="nc"><i>263</i>&nbsp;				Object noCache = pageInfo.getCacheDirectives().get(&quot;no-cache&quot;);</b>
<b class="nc"><i>264</i>&nbsp;				if (noCache instanceof Boolean &amp;&amp; ((Boolean)noCache)) {</b>
<b class="nc"><i>265</i>&nbsp;					log.debug(&quot;Response ok but Cache-Control: no-cache is present, not caching&quot;);</b>
<b class="nc"><i>266</i>&nbsp;					releaseCacheLocks(operationsByType, key);</b>
<i>267</i>&nbsp;				}
<i>268</i>&nbsp;				else {
<b class="nc"><i>269</i>&nbsp;					Collection&lt;Cache&gt; caches = new ArrayList&lt;Cache&gt;();</b>
<b class="nc"><i>270</i>&nbsp;					for (CacheOperationContext operationContext : operationsByType.get(UPDATE)) {</b>
<b class="nc"><i>271</i>&nbsp;						for (Cache cache : operationContext.getCaches()) {</b>
<b class="nc"><i>272</i>&nbsp;							caches.add(cache);</b>
<b class="nc"><i>273</i>&nbsp;						}</b>
<b class="nc"><i>274</i>&nbsp;					}</b>
<b class="nc"><i>275</i>&nbsp;					update(caches, pageInfo, cacheStatus, key);</b>
<i>276</i>&nbsp;				}
<b class="nc"><i>277</i>&nbsp;			}</b>
<i>278</i>&nbsp;			else {
<b class="nc"><i>279</i>&nbsp;				for (CacheOperationContext operationContext : operationsByType.get(UPDATE)) {</b>
<b class="nc"><i>280</i>&nbsp;					for (Cache cache : operationContext.getCaches()) {</b>
<b class="nc"><i>281</i>&nbsp;						log.debug(&quot;Response not ok ({}). Putting null into cache {} with key {}&quot;,</b>
<i>282</i>&nbsp;								new Object[] { pageInfo.getStatusCode(), cache.getName(), key } );
<b class="nc"><i>283</i>&nbsp;					}</b>
<b class="nc"><i>284</i>&nbsp;				}</b>
<b class="nc"><i>285</i>&nbsp;				releaseCacheLocks(operationsByType, key);</b>
<i>286</i>&nbsp;			}
<i>287</i>&nbsp;		}
<b class="nc"><i>288</i>&nbsp;		catch (Exception e) {</b>
<b class="nc"><i>289</i>&nbsp;            if(&quot;net.sf.ehcache.constructs.blocking.LockTimeoutException&quot;.equals(e.getClass().getName())) {</b>
<i>290</i>&nbsp;			    //do not release the lock, because you never acquired it
<b class="nc"><i>291</i>&nbsp;			    throw e;</b>
<i>292</i>&nbsp;            }
<i>293</i>&nbsp;			// Must unlock the cache if the above fails. Will be logged at Filter
<b class="nc"><i>294</i>&nbsp;			releaseCacheLocks(operationsByType, key);</b>
<b class="nc"><i>295</i>&nbsp;			throw e;</b>
<b class="nc"><i>296</i>&nbsp;		}</b>
<i>297</i>&nbsp;
<b class="nc"><i>298</i>&nbsp;		timer.stop(false);</b>
<b class="nc"><i>299</i>&nbsp;		response.addHeader(X_CACHED, String.valueOf(false));</b>
<b class="nc"><i>300</i>&nbsp;		return pageInfo;</b>
<i>301</i>&nbsp;	}
<i>302</i>&nbsp;
<i>303</i>&nbsp;	protected PageInfo buildCachedPageInfo(HttpServletRequest request, HttpServletResponse response,
<i>304</i>&nbsp;			CacheStatus cacheStatus) throws Exception {
<i>305</i>&nbsp;
<b class="nc"><i>306</i>&nbsp;		Timer timer = new Timer(getCachedUri(request));</b>
<b class="nc"><i>307</i>&nbsp;		timer.start();</b>
<i>308</i>&nbsp;
<b class="nc"><i>309</i>&nbsp;		String key = calculateKey(request);</b>
<i>310</i>&nbsp;		PageInfo pageInfo;
<b class="nc"><i>311</i>&nbsp;		ValueWrapper element = cacheStatus.valueWrapper;</b>
<b class="nc"><i>312</i>&nbsp;		log.debug(&quot;Serving cached content for {}&quot;, key);</b>
<b class="nc"><i>313</i>&nbsp;		pageInfo = (PageInfo) element.get();</b>
<i>314</i>&nbsp;
<b class="nc"><i>315</i>&nbsp;		for (Map.Entry&lt;String, ? extends Serializable&gt; entry : pageInfo.getRequestAttributes().entrySet()) {</b>
<b class="nc"><i>316</i>&nbsp;			request.setAttribute(entry.getKey(), entry.getValue());</b>
<b class="nc"><i>317</i>&nbsp;		}</b>
<i>318</i>&nbsp;
<i>319</i>&nbsp;		// As the page is cached, we need to add an instance of the associated
<i>320</i>&nbsp;		// controller to the request. This is required by GrailsLayoutDecoratorMapper
<i>321</i>&nbsp;		// to pick the appropriate layout.
<b class="nc"><i>322</i>&nbsp;		if (StringUtils.hasLength(getContext().getControllerName())) {</b>
<b class="nc"><i>323</i>&nbsp;			Object controller = lookupController(getContext().getControllerClass());</b>
<b class="nc"><i>324</i>&nbsp;			request.setAttribute(GrailsApplicationAttributes.CONTROLLER, controller);</b>
<i>325</i>&nbsp;		}
<b class="nc"><i>326</i>&nbsp;		timer.stop(true);</b>
<b class="nc"><i>327</i>&nbsp;		response.addHeader(X_CACHED, String.valueOf(true));</b>
<b class="nc"><i>328</i>&nbsp;		return pageInfo;</b>
<i>329</i>&nbsp;	}
<i>330</i>&nbsp;
<i>331</i>&nbsp;	protected abstract int getTimeToLive(ValueWrapper element);
<i>332</i>&nbsp;
<i>333</i>&nbsp;	/**
<i>334</i>&nbsp;	 * Store the PageInfo in the cache with the specified ttl.
<i>335</i>&nbsp;	 * @param cache the cache
<i>336</i>&nbsp;	 * @param key the key
<i>337</i>&nbsp;	 * @param pageInfo the info
<i>338</i>&nbsp;	 * @param timeToLive the ttl
<i>339</i>&nbsp;	 */
<i>340</i>&nbsp;	protected abstract void put(Cache cache, String key, PageInfo pageInfo, Integer timeToLive);
<i>341</i>&nbsp;
<i>342</i>&nbsp;	protected void releaseCacheLocks(Map&lt;String, Collection&lt;CacheOperationContext&gt;&gt; operationsByType, String key) {
<i>343</i>&nbsp;//		/*Blocking*/Cache cache
<i>344</i>&nbsp;		// TODO is this needed since inspectBeforeCacheEvicts seems to do the right thing?
<i>345</i>&nbsp;
<b class="nc"><i>346</i>&nbsp;		for (CacheOperationContext operationContext : operationsByType.get(EVICT)) {</b>
<b class="nc"><i>347</i>&nbsp;			for (Cache cache : operationContext.getCaches()) {</b>
<b class="nc"><i>348</i>&nbsp;				put(cache, key, null, null);</b>
<b class="nc"><i>349</i>&nbsp;			}</b>
<b class="nc"><i>350</i>&nbsp;		}</b>
<i>351</i>&nbsp;	}
<i>352</i>&nbsp;
<i>353</i>&nbsp;	protected PageInfo buildPage(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {
<i>354</i>&nbsp;		// Invoke the next entity in the chain
<b class="nc"><i>355</i>&nbsp;		SerializableByteArrayOutputStream out = new SerializableByteArrayOutputStream();</b>
<b class="nc"><i>356</i>&nbsp;		GenericResponseWrapper wrapper = new GenericResponseWrapper(response, out);</b>
<b class="nc"><i>357</i>&nbsp;		Map&lt;String, Serializable&gt; cacheableRequestAttributes = new HashMap&lt;String, Serializable&gt;();</b>
<i>358</i>&nbsp;
<i>359</i>&nbsp;		// TODO: split the special include handling out into a separate method
<b class="nc"><i>360</i>&nbsp;		HttpServletResponse originalResponse = null;</b>
<b class="nc"><i>361</i>&nbsp;		boolean isInclude = WebUtils.isIncludeRequest(request);</b>
<b class="nc"><i>362</i>&nbsp;		if (isInclude) {</b>
<b class="nc"><i>363</i>&nbsp;			originalResponse = WrappedResponseHolder.getWrappedResponse();</b>
<b class="nc"><i>364</i>&nbsp;			WrappedResponseHolder.setWrappedResponse(wrapper);</b>
<i>365</i>&nbsp;		}
<i>366</i>&nbsp;		try {
<b class="nc"><i>367</i>&nbsp;			List&lt;String&gt; attributesBefore = toList(request.getAttributeNames());</b>
<b class="nc"><i>368</i>&nbsp;			chain.doFilter(request, wrapper);</b>
<b class="nc"><i>369</i>&nbsp;			List&lt;String&gt; attributesAfter = toList(request.getAttributeNames());</b>
<b class="nc"><i>370</i>&nbsp;			attributesAfter.removeAll(attributesBefore);</b>
<b class="nc"><i>371</i>&nbsp;			for (String attrName : attributesAfter) {</b>
<b class="nc"><i>372</i>&nbsp;				Object value = request.getAttribute(attrName);</b>
<b class="nc"><i>373</i>&nbsp;				if (value instanceof Serializable) {</b>
<b class="nc"><i>374</i>&nbsp;					cacheableRequestAttributes.put(attrName, (Serializable)value);</b>
<i>375</i>&nbsp;				}
<b class="nc"><i>376</i>&nbsp;			}</b>
<i>377</i>&nbsp;		}
<i>378</i>&nbsp;		finally {
<b class="nc"><i>379</i>&nbsp;			if (isInclude) {</b>
<b class="nc"><i>380</i>&nbsp;				WrappedResponseHolder.setWrappedResponse(originalResponse);</b>
<i>381</i>&nbsp;			}
<i>382</i>&nbsp;		}
<b class="nc"><i>383</i>&nbsp;		wrapper.flush();</b>
<i>384</i>&nbsp;
<b class="nc"><i>385</i>&nbsp;		long timeToLiveSeconds = Integer.MAX_VALUE; // TODO cacheManager.getEhcache(context.cacheName).cacheConfiguration.timeToLiveSeconds;</b>
<i>386</i>&nbsp;
<b class="nc"><i>387</i>&nbsp;		String contentType = wrapper.getContentType();</b>
<b class="nc"><i>388</i>&nbsp;		if (!StringUtils.hasLength(contentType)) {</b>
<b class="nc"><i>389</i>&nbsp;			contentType = response.getContentType();</b>
<i>390</i>&nbsp;		}
<i>391</i>&nbsp;
<b class="nc"><i>392</i>&nbsp;		return new PageInfo(wrapper.getStatus(), contentType, out.toByteArray(),</b>
<i>393</i>&nbsp;			false, timeToLiveSeconds, wrapper.getAllHeaders(), wrapper.getCookies(), cacheableRequestAttributes);
<i>394</i>&nbsp;	}
<i>395</i>&nbsp;
<i>396</i>&nbsp;	protected List&lt;String&gt; toList(Enumeration&lt;String&gt; e) {
<b class="nc"><i>397</i>&nbsp;		List&lt;String&gt; list = new ArrayList&lt;String&gt;();</b>
<b class="nc"><i>398</i>&nbsp;		while (e.hasMoreElements()) {</b>
<b class="nc"><i>399</i>&nbsp;			list.add(e.nextElement());</b>
<i>400</i>&nbsp;		}
<b class="nc"><i>401</i>&nbsp;		return list;</b>
<i>402</i>&nbsp;	}
<i>403</i>&nbsp;
<i>404</i>&nbsp;	protected String calculateKey(HttpServletRequest request) {
<b class="nc"><i>405</i>&nbsp;		return keyGenerator.generate(request);</b>
<i>406</i>&nbsp;	}
<i>407</i>&nbsp;
<i>408</i>&nbsp;	/**
<i>409</i>&nbsp;	 * Writes the response from a PageInfo object.
<i>410</i>&nbsp;	 * &lt;p/&gt;
<i>411</i>&nbsp;	 * Headers are set last so that there is an opportunity to override
<i>412</i>&nbsp;	 *
<i>413</i>&nbsp;	 * 1 - only set status, contentType, cookies, etc. if this is the &quot;main&quot;
<i>414</i>&nbsp;	 * request and not an include. 2 - send a status code 304 if appropriate.
<i>415</i>&nbsp;	 *
<i>416</i>&nbsp;	 * @param request
<i>417</i>&nbsp;	 * @param response
<i>418</i>&nbsp;	 * @param pageInfo
<i>419</i>&nbsp;	 * @throws IOException
<i>420</i>&nbsp;	 */
<i>421</i>&nbsp;	protected void writeResponse(final HttpServletRequest request, final HttpServletResponse response,
<i>422</i>&nbsp;			final PageInfo pageInfo) throws IOException {
<i>423</i>&nbsp;
<b class="nc"><i>424</i>&nbsp;		if (!WebUtils.isIncludeRequest(request)) {</b>
<b class="nc"><i>425</i>&nbsp;			int statusCode = determineResponseStatus(request, pageInfo);</b>
<b class="nc"><i>426</i>&nbsp;			response.setStatus(statusCode);</b>
<b class="nc"><i>427</i>&nbsp;			setContentType(response, pageInfo);</b>
<b class="nc"><i>428</i>&nbsp;			setCookies(pageInfo, response);</b>
<b class="nc"><i>429</i>&nbsp;			setHeaders(pageInfo, response);</b>
<i>430</i>&nbsp;		}
<b class="nc"><i>431</i>&nbsp;		writeResponse(response, pageInfo);</b>
<i>432</i>&nbsp;	}
<i>433</i>&nbsp;
<i>434</i>&nbsp;	protected int determineResponseStatus(HttpServletRequest request, PageInfo pageInfo) {
<b class="nc"><i>435</i>&nbsp;		int statusCode = pageInfo.getStatusCode();</b>
<b class="nc"><i>436</i>&nbsp;		if (!pageInfo.isModified(request)) {</b>
<b class="nc"><i>437</i>&nbsp;			log.debug(&quot;Content not modified since {} sending 304&quot;, request.getHeader(HttpHeaders.IF_MODIFIED_SINCE));</b>
<b class="nc"><i>438</i>&nbsp;			statusCode = HttpServletResponse.SC_NOT_MODIFIED;</b>
<i>439</i>&nbsp;		}
<b class="nc"><i>440</i>&nbsp;		else if (pageInfo.isMatch(request)) {</b>
<b class="nc"><i>441</i>&nbsp;			log.debug(&quot;Content matches entity tag {} sending 304&quot;, request.getHeader(HttpHeaders.IF_NONE_MATCH));</b>
<b class="nc"><i>442</i>&nbsp;			statusCode = HttpServletResponse.SC_NOT_MODIFIED;</b>
<i>443</i>&nbsp;		}
<b class="nc"><i>444</i>&nbsp;		return statusCode;</b>
<i>445</i>&nbsp;	}
<i>446</i>&nbsp;
<i>447</i>&nbsp;	protected void setContentType(final HttpServletResponse response, final PageInfo pageInfo) {
<b class="nc"><i>448</i>&nbsp;		String contentType = pageInfo.getContentType();</b>
<b class="nc"><i>449</i>&nbsp;		if (contentType != null &amp;&amp; contentType.length() &gt; 0) {</b>
<b class="nc"><i>450</i>&nbsp;			response.setContentType(contentType);</b>
<i>451</i>&nbsp;		}
<i>452</i>&nbsp;	}
<i>453</i>&nbsp;
<i>454</i>&nbsp;	protected void setCookies(final PageInfo pageInfo, final HttpServletResponse response) {
<b class="nc"><i>455</i>&nbsp;		Collection&lt;SerializableCookie&gt; cookies = pageInfo.getSerializableCookies();</b>
<b class="nc"><i>456</i>&nbsp;		for (SerializableCookie cookie : cookies) {</b>
<b class="nc"><i>457</i>&nbsp;			response.addCookie(cookie.toCookie());</b>
<b class="nc"><i>458</i>&nbsp;		}</b>
<i>459</i>&nbsp;	}
<i>460</i>&nbsp;
<i>461</i>&nbsp;	/**
<i>462</i>&nbsp;	 * Set the headers in the response object, excluding the Gzip header
<i>463</i>&nbsp;	 * @param pageInfo
<i>464</i>&nbsp;	 * @param response
<i>465</i>&nbsp;	 */
<i>466</i>&nbsp;	protected void setHeaders(final PageInfo pageInfo, final HttpServletResponse response) {
<i>467</i>&nbsp;
<b class="nc"><i>468</i>&nbsp;		Collection&lt;Header&lt;? extends Serializable&gt;&gt; headers = pageInfo.getHeaders();</b>
<i>469</i>&nbsp;
<i>470</i>&nbsp;		// Track which headers have been set so all headers of the same name
<i>471</i>&nbsp;		// after the first are added
<b class="nc"><i>472</i>&nbsp;		TreeSet&lt;String&gt; setHeaders = new TreeSet&lt;String&gt;(String.CASE_INSENSITIVE_ORDER);</b>
<i>473</i>&nbsp;
<b class="nc"><i>474</i>&nbsp;		for (Header&lt;? extends Serializable&gt; header : headers) {</b>
<b class="nc"><i>475</i>&nbsp;			String name = header.getName();</b>
<i>476</i>&nbsp;
<b class="nc"><i>477</i>&nbsp;			switch (header.getType()) {</b>
<i>478</i>&nbsp;				case STRING:
<b class="nc"><i>479</i>&nbsp;					if (setHeaders.contains(name)) {</b>
<b class="nc"><i>480</i>&nbsp;						response.addHeader(name, (String) header.getValue());</b>
<i>481</i>&nbsp;					}
<i>482</i>&nbsp;					else {
<b class="nc"><i>483</i>&nbsp;						setHeaders.add(name);</b>
<b class="nc"><i>484</i>&nbsp;						response.setHeader(name, (String) header.getValue());</b>
<i>485</i>&nbsp;					}
<b class="nc"><i>486</i>&nbsp;					break;</b>
<i>487</i>&nbsp;				case DATE:
<b class="nc"><i>488</i>&nbsp;					if (setHeaders.contains(name)) {</b>
<b class="nc"><i>489</i>&nbsp;						response.addDateHeader(name, (Long) header.getValue());</b>
<i>490</i>&nbsp;					}
<i>491</i>&nbsp;					else {
<b class="nc"><i>492</i>&nbsp;						setHeaders.add(name);</b>
<b class="nc"><i>493</i>&nbsp;						response.setDateHeader(name, (Long) header.getValue());</b>
<i>494</i>&nbsp;					}
<b class="nc"><i>495</i>&nbsp;					break;</b>
<i>496</i>&nbsp;				case INT:
<b class="nc"><i>497</i>&nbsp;					if (setHeaders.contains(name)) {</b>
<b class="nc"><i>498</i>&nbsp;						response.addIntHeader(name, (Integer) header.getValue());</b>
<i>499</i>&nbsp;					}
<i>500</i>&nbsp;					else {
<b class="nc"><i>501</i>&nbsp;						setHeaders.add(name);</b>
<b class="nc"><i>502</i>&nbsp;						response.setIntHeader(name, (Integer) header.getValue());</b>
<i>503</i>&nbsp;					}
<b class="nc"><i>504</i>&nbsp;					break;</b>
<i>505</i>&nbsp;				default:
<b class="nc"><i>506</i>&nbsp;					throw new IllegalArgumentException(&quot;No mapping for Header: &quot; + header);</b>
<i>507</i>&nbsp;			}
<b class="nc"><i>508</i>&nbsp;		}</b>
<i>509</i>&nbsp;	}
<i>510</i>&nbsp;
<i>511</i>&nbsp;	protected void initContext() {
<b class="nc"><i>512</i>&nbsp;		GrailsWebRequest requestAttributes = (GrailsWebRequest)RequestContextHolder.getRequestAttributes();</b>
<b class="nc"><i>513</i>&nbsp;		contextHolder.get().push(new ContentCacheParameters(requestAttributes));</b>
<i>514</i>&nbsp;	}
<i>515</i>&nbsp;
<i>516</i>&nbsp;	protected ContentCacheParameters getContext() {
<b class="nc"><i>517</i>&nbsp;		return contextHolder.get().peek();</b>
<i>518</i>&nbsp;	}
<i>519</i>&nbsp;
<i>520</i>&nbsp;	protected void destroyContext() {
<b class="nc"><i>521</i>&nbsp;		contextHolder.get().pop();</b>
<b class="nc"><i>522</i>&nbsp;		if (contextHolder.get().empty()) {</b>
<b class="nc"><i>523</i>&nbsp;			contextHolder.remove();</b>
<i>524</i>&nbsp;		}
<i>525</i>&nbsp;	}
<i>526</i>&nbsp;
<i>527</i>&nbsp;	protected String getCachedUri(HttpServletRequest request) {
<b class="nc"><i>528</i>&nbsp;		if (WebUtils.isIncludeRequest(request)) {</b>
<b class="nc"><i>529</i>&nbsp;			return (String)request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE);</b>
<i>530</i>&nbsp;		}
<b class="nc"><i>531</i>&nbsp;		return request.getRequestURI();</b>
<i>532</i>&nbsp;	}
<i>533</i>&nbsp;
<i>534</i>&nbsp;	protected void logRequestDetails(HttpServletRequest request, ContentCacheParameters cacheParameters, String message) {
<b class="nc"><i>535</i>&nbsp;		if (!log.isDebugEnabled()) {</b>
<i>536</i>&nbsp;			return;
<i>537</i>&nbsp;		}
<i>538</i>&nbsp;
<b class="nc"><i>539</i>&nbsp;		log.debug(&quot;{}...&quot;, message);</b>
<b class="nc"><i>540</i>&nbsp;		log.debug(&quot;    method = {}&quot;, request.getMethod());</b>
<b class="nc"><i>541</i>&nbsp;		log.debug(&quot;    requestURI = {}&quot;, request.getRequestURI());</b>
<b class="nc"><i>542</i>&nbsp;		log.debug(&quot;    forwardURI = {}&quot;, WebUtils.getForwardURI(request));</b>
<b class="nc"><i>543</i>&nbsp;		if (WebUtils.isIncludeRequest(request)) {</b>
<b class="nc"><i>544</i>&nbsp;			log.debug(&quot;    includeURI = {}&quot;, request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE));</b>
<i>545</i>&nbsp;		}
<b class="nc"><i>546</i>&nbsp;		log.debug(&quot;    controller = {}&quot;, cacheParameters.getControllerName());</b>
<b class="nc"><i>547</i>&nbsp;		log.debug(&quot;    action = {}&quot;, cacheParameters.getActionName());</b>
<b class="nc"><i>548</i>&nbsp;		RequestMimeTypesApi requestMimeTypesApi = getBean(&quot;requestMimeTypesApi&quot;);</b>
<b class="nc"><i>549</i>&nbsp;		log.debug(&quot;    format = {}&quot;, requestMimeTypesApi.getFormat(request));</b>
<b class="nc"><i>550</i>&nbsp;		log.debug(&quot;    params = {}&quot;, cacheParameters.getParams());</b>
<i>551</i>&nbsp;	}
<i>552</i>&nbsp;
<i>553</i>&nbsp;	protected Map&lt;String, Collection&lt;CacheOperationContext&gt;&gt; createOperationContext(
<i>554</i>&nbsp;			Collection&lt;CacheOperation&gt; cacheOperations, Method method,
<i>555</i>&nbsp;			Class&lt;?&gt; targetClass, HttpServletRequest request) {
<i>556</i>&nbsp;
<b class="nc"><i>557</i>&nbsp;		Map&lt;String, Collection&lt;CacheOperationContext&gt;&gt; map = new LinkedHashMap&lt;String, Collection&lt;CacheOperationContext&gt;&gt;(3);</b>
<i>558</i>&nbsp;
<b class="nc"><i>559</i>&nbsp;		Collection&lt;CacheOperationContext&gt; cacheables = new ArrayList&lt;CacheOperationContext&gt;();</b>
<b class="nc"><i>560</i>&nbsp;		Collection&lt;CacheOperationContext&gt; evicts = new ArrayList&lt;CacheOperationContext&gt;();</b>
<b class="nc"><i>561</i>&nbsp;		Collection&lt;CacheOperationContext&gt; updates = new ArrayList&lt;CacheOperationContext&gt;();</b>
<i>562</i>&nbsp;
<b class="nc"><i>563</i>&nbsp;		Object[] args = findArgs(request, method);</b>
<i>564</i>&nbsp;
<b class="nc"><i>565</i>&nbsp;		for (CacheOperation cacheOperation : cacheOperations) {</b>
<b class="nc"><i>566</i>&nbsp;			CacheOperationContext opContext = new CacheOperationContext(</b>
<i>567</i>&nbsp;					cacheOperation, method, args, targetClass, getCaches(cacheOperation),
<i>568</i>&nbsp;					expressionEvaluator, keyGenerator, request);
<i>569</i>&nbsp;
<b class="nc"><i>570</i>&nbsp;			if (cacheOperation instanceof CacheableOperation) {</b>
<b class="nc"><i>571</i>&nbsp;				cacheables.add(opContext);</b>
<i>572</i>&nbsp;			}
<i>573</i>&nbsp;
<b class="nc"><i>574</i>&nbsp;			if (cacheOperation instanceof CacheEvictOperation) {</b>
<b class="nc"><i>575</i>&nbsp;				evicts.add(opContext);</b>
<i>576</i>&nbsp;			}
<i>577</i>&nbsp;
<b class="nc"><i>578</i>&nbsp;			if (cacheOperation instanceof CachePutOperation) {</b>
<b class="nc"><i>579</i>&nbsp;				updates.add(opContext);</b>
<i>580</i>&nbsp;			}
<b class="nc"><i>581</i>&nbsp;		}</b>
<i>582</i>&nbsp;
<b class="nc"><i>583</i>&nbsp;		map.put(CACHEABLE, cacheables);</b>
<b class="nc"><i>584</i>&nbsp;		map.put(EVICT, evicts);</b>
<b class="nc"><i>585</i>&nbsp;		map.put(UPDATE, updates);</b>
<i>586</i>&nbsp;
<b class="nc"><i>587</i>&nbsp;		return map;</b>
<i>588</i>&nbsp;	}
<i>589</i>&nbsp;
<i>590</i>&nbsp;	protected Object[] findArgs(HttpServletRequest request, Method method) {
<b class="nc"><i>591</i>&nbsp;		String[] names = paramNameDiscoverer.getParameterNames(method);</b>
<b class="nc"><i>592</i>&nbsp;		if (names == null) {</b>
<b class="nc"><i>593</i>&nbsp;			log.warn(&quot;Unable to lookup parameter names for method &quot; + method);</b>
<b class="nc"><i>594</i>&nbsp;			return null;</b>
<i>595</i>&nbsp;		}
<i>596</i>&nbsp;
<b class="nc"><i>597</i>&nbsp;		List&lt;Object&gt; args = new ArrayList&lt;Object&gt;();</b>
<b class="nc"><i>598</i>&nbsp;		Class&lt;?&gt;[] types = method.getParameterTypes();</b>
<b class="nc"><i>599</i>&nbsp;		for (int i = 0, count = types.length; i &lt; count; i++) {</b>
<b class="nc"><i>600</i>&nbsp;			args.add(findArg(request, types[i], names[i]));</b>
<i>601</i>&nbsp;		}
<b class="nc"><i>602</i>&nbsp;		return args.toArray();</b>
<i>603</i>&nbsp;	}
<i>604</i>&nbsp;
<i>605</i>&nbsp;	protected Object findArg(HttpServletRequest request, Class&lt;?&gt; type, String name) {
<i>606</i>&nbsp;
<b class="nc"><i>607</i>&nbsp;		if (String.class.equals(type)) {</b>
<b class="nc"><i>608</i>&nbsp;			return request.getParameter(name);</b>
<i>609</i>&nbsp;		}
<i>610</i>&nbsp;
<b class="nc"><i>611</i>&nbsp;		if (PRIMITIVE_CLASSES.contains(type) || TYPE_TO_CONVERSION_METHOD_NAME.containsKey(type)) {</b>
<i>612</i>&nbsp;
<i>613</i>&nbsp;			String conversionMethodName;
<b class="nc"><i>614</i>&nbsp;			if (TYPE_TO_CONVERSION_METHOD_NAME.containsKey(type)) {</b>
<b class="nc"><i>615</i>&nbsp;				conversionMethodName = TYPE_TO_CONVERSION_METHOD_NAME.get(type);</b>
<i>616</i>&nbsp;			}
<i>617</i>&nbsp;			else {
<b class="nc"><i>618</i>&nbsp;				conversionMethodName = type.getName();</b>
<i>619</i>&nbsp;			}
<i>620</i>&nbsp;
<b class="nc"><i>621</i>&nbsp;			GrailsWebRequest grailsRequest = (GrailsWebRequest)RequestContextHolder.getRequestAttributes();</b>
<b class="nc"><i>622</i>&nbsp;			GrailsParameterMap params = grailsRequest.getParams();</b>
<i>623</i>&nbsp;
<b class="nc"><i>624</i>&nbsp;			return getParamValue(params, conversionMethodName, name);</b>
<i>625</i>&nbsp;		}
<i>626</i>&nbsp;
<b class="nc"><i>627</i>&nbsp;		log.warn(&quot;Unsupported parameter type &quot; + type + &quot; for parameter &quot; + name);</b>
<b class="nc"><i>628</i>&nbsp;		return null;</b>
<i>629</i>&nbsp;	}
<i>630</i>&nbsp;
<i>631</i>&nbsp;	protected Object getParamValue(GrailsParameterMap params, String conversionMethodName, String paramName) {
<b class="nc"><i>632</i>&nbsp;		Method method = PARAMS_METHODS.get(conversionMethodName);</b>
<b class="nc"><i>633</i>&nbsp;		if (method == null) {</b>
<b class="nc"><i>634</i>&nbsp;			log.warn(&quot;No method found for &quot; + conversionMethodName + &quot; in GrailsParameterMap&quot;);</b>
<b class="nc"><i>635</i>&nbsp;			return null;</b>
<i>636</i>&nbsp;		}
<i>637</i>&nbsp;
<b class="nc"><i>638</i>&nbsp;		return ReflectionUtils.invokeMethod(method, params, paramName);</b>
<i>639</i>&nbsp;	}
<i>640</i>&nbsp;
<i>641</i>&nbsp;	protected Collection&lt;Cache&gt; getCaches(CacheOperation operation) {
<b class="nc"><i>642</i>&nbsp;		Set&lt;String&gt; cacheNames = operation.getCacheNames();</b>
<b class="nc"><i>643</i>&nbsp;		Collection&lt;Cache&gt; caches = new ArrayList&lt;Cache&gt;(cacheNames.size());</b>
<b class="nc"><i>644</i>&nbsp;		for (String name : cacheNames) {</b>
<b class="nc"><i>645</i>&nbsp;			Cache cache = getCacheManager().getCache(name);</b>
<b class="nc"><i>646</i>&nbsp;			if (cache == null) {</b>
<b class="nc"><i>647</i>&nbsp;				throw new IllegalArgumentException(&quot;Cannot find cache named [&quot; + name + &quot;] for &quot; + operation);</b>
<i>648</i>&nbsp;			}
<b class="nc"><i>649</i>&nbsp;			caches.add(cache);</b>
<b class="nc"><i>650</i>&nbsp;		}</b>
<b class="nc"><i>651</i>&nbsp;		return caches;</b>
<i>652</i>&nbsp;	}
<i>653</i>&nbsp;
<i>654</i>&nbsp;	protected boolean inspectBeforeCacheEvicts(Collection&lt;CacheOperationContext&gt; evictions) {
<b class="nc"><i>655</i>&nbsp;		return inspectCacheEvicts(evictions, true);</b>
<i>656</i>&nbsp;	}
<i>657</i>&nbsp;
<i>658</i>&nbsp;	protected boolean inspectAfterCacheEvicts(Collection&lt;CacheOperationContext&gt; evictions) {
<b class="nc"><i>659</i>&nbsp;		return inspectCacheEvicts(evictions, false);</b>
<i>660</i>&nbsp;	}
<i>661</i>&nbsp;
<i>662</i>&nbsp;	protected boolean inspectCacheEvicts(Collection&lt;CacheOperationContext&gt; evictions, boolean beforeInvocation) {
<b class="nc"><i>663</i>&nbsp;		if (evictions.isEmpty()) {</b>
<b class="nc"><i>664</i>&nbsp;			return false;</b>
<i>665</i>&nbsp;		}
<i>666</i>&nbsp;
<b class="nc"><i>667</i>&nbsp;		boolean trace = log.isTraceEnabled();</b>
<i>668</i>&nbsp;
<b class="nc"><i>669</i>&nbsp;		boolean atLeastOne = false;</b>
<b class="nc"><i>670</i>&nbsp;		for (CacheOperationContext operationContext : evictions) {</b>
<b class="nc"><i>671</i>&nbsp;			CacheEvictOperation evict = (CacheEvictOperation) operationContext.operation;</b>
<i>672</i>&nbsp;
<b class="nc"><i>673</i>&nbsp;			if (beforeInvocation == evict.isBeforeInvocation()) {</b>
<b class="nc"><i>674</i>&nbsp;				if (operationContext.isConditionPassing()) {</b>
<b class="nc"><i>675</i>&nbsp;					atLeastOne = true;</b>
<i>676</i>&nbsp;					// for each cache
<i>677</i>&nbsp;					// lazy key initialization
<b class="nc"><i>678</i>&nbsp;					Object key = null;</b>
<i>679</i>&nbsp;
<b class="nc"><i>680</i>&nbsp;					for (Cache cache : operationContext.getCaches()) {</b>
<i>681</i>&nbsp;						// cache-wide flush
<b class="nc"><i>682</i>&nbsp;						if (evict.isCacheWide()) {</b>
<b class="nc"><i>683</i>&nbsp;							cache.clear();</b>
<b class="nc"><i>684</i>&nbsp;							logRequestDetails(operationContext.request, getContext(), &quot;Flushing request&quot;);</b>
<i>685</i>&nbsp;						}
<i>686</i>&nbsp;						else {
<i>687</i>&nbsp;							// check key
<b class="nc"><i>688</i>&nbsp;							if (key == null) {</b>
<b class="nc"><i>689</i>&nbsp;								key = operationContext.generateKey();</b>
<i>690</i>&nbsp;							}
<b class="nc"><i>691</i>&nbsp;							if (trace) {</b>
<b class="nc"><i>692</i>&nbsp;								log.trace(&quot;Invalidating cache key {} for operation {} on method {}&quot;,</b>
<i>693</i>&nbsp;										new Object[] { key, evict, operationContext.method });
<i>694</i>&nbsp;							}
<b class="nc"><i>695</i>&nbsp;							cache.evict(key);</b>
<i>696</i>&nbsp;						}
<b class="nc"><i>697</i>&nbsp;					}</b>
<b class="nc"><i>698</i>&nbsp;				}</b>
<i>699</i>&nbsp;				else {
<b class="nc"><i>700</i>&nbsp;					logRequestDetails(operationContext.request, getContext(), &quot;Not flushing request&quot;);</b>
<i>701</i>&nbsp;				}
<i>702</i>&nbsp;			}
<b class="nc"><i>703</i>&nbsp;		}</b>
<b class="nc"><i>704</i>&nbsp;		return atLeastOne;</b>
<i>705</i>&nbsp;	}
<i>706</i>&nbsp;
<i>707</i>&nbsp;	protected CacheStatus inspectCacheables(Collection&lt;CacheOperationContext&gt; cacheables) {
<i>708</i>&nbsp;
<b class="nc"><i>709</i>&nbsp;		if (cacheables.isEmpty()) {</b>
<b class="nc"><i>710</i>&nbsp;			return null;</b>
<i>711</i>&nbsp;		}
<i>712</i>&nbsp;
<b class="nc"><i>713</i>&nbsp;		Map&lt;CacheOperationContext, Object&gt; cUpdates = new LinkedHashMap&lt;CacheOperationContext, Object&gt;(cacheables.size());</b>
<i>714</i>&nbsp;
<b class="nc"><i>715</i>&nbsp;		boolean trace = log.isTraceEnabled();</b>
<b class="nc"><i>716</i>&nbsp;		boolean updateRequired = false;</b>
<b class="nc"><i>717</i>&nbsp;		boolean atLeastOne = false;</b>
<i>718</i>&nbsp;
<b class="nc"><i>719</i>&nbsp;		ValueWrapper valueWrapper = null;</b>
<i>720</i>&nbsp;
<b class="nc"><i>721</i>&nbsp;		for (CacheOperationContext context : cacheables) {</b>
<b class="nc"><i>722</i>&nbsp;			if (context.isConditionPassing()) {</b>
<b class="nc"><i>723</i>&nbsp;				atLeastOne = true;</b>
<b class="nc"><i>724</i>&nbsp;				Object key = context.generateKey();</b>
<i>725</i>&nbsp;
<b class="nc"><i>726</i>&nbsp;				if (trace) {</b>
<b class="nc"><i>727</i>&nbsp;					log.trace(&quot;Computed cache key {} for operation {}&quot;, new Object[] { key, context.operation });</b>
<i>728</i>&nbsp;				}
<b class="nc"><i>729</i>&nbsp;				if (key == null) {</b>
<b class="nc"><i>730</i>&nbsp;					throw new IllegalArgumentException(</b>
<i>731</i>&nbsp;							&quot;Null key returned for cache operation (maybe you are using named params on classes without debug info?) &quot; +
<i>732</i>&nbsp;							context.operation);
<i>733</i>&nbsp;				}
<i>734</i>&nbsp;
<i>735</i>&nbsp;				// add op/key (in case an update is discovered later on)
<b class="nc"><i>736</i>&nbsp;				cUpdates.put(context, key);</b>
<i>737</i>&nbsp;
<b class="nc"><i>738</i>&nbsp;				boolean localCacheHit = false;</b>
<i>739</i>&nbsp;
<i>740</i>&nbsp;				// check whether the cache needs to be inspected or not (the method will be invoked anyway)
<b class="nc"><i>741</i>&nbsp;				if (!updateRequired) {</b>
<b class="nc"><i>742</i>&nbsp;					for (Cache cache : context.getCaches()) {</b>
<b class="nc"><i>743</i>&nbsp;						ValueWrapper wrapper = cache.get(key);</b>
<b class="nc"><i>744</i>&nbsp;						if (wrapper != null) {</b>
<b class="nc"><i>745</i>&nbsp;							valueWrapper = wrapper;</b>
<b class="nc"><i>746</i>&nbsp;							localCacheHit = true;</b>
<b class="nc"><i>747</i>&nbsp;							break;</b>
<i>748</i>&nbsp;						}
<b class="nc"><i>749</i>&nbsp;					}</b>
<i>750</i>&nbsp;				}
<i>751</i>&nbsp;
<b class="nc"><i>752</i>&nbsp;				if (!localCacheHit) {</b>
<b class="nc"><i>753</i>&nbsp;					updateRequired = true;</b>
<i>754</i>&nbsp;				}
<b class="nc"><i>755</i>&nbsp;			}</b>
<i>756</i>&nbsp;			else {
<b class="nc"><i>757</i>&nbsp;				if (trace) {</b>
<b class="nc"><i>758</i>&nbsp;					log.trace(&quot;Cache condition failed on method {} for operation {}&quot;, new Object[] { context.method, context.operation });</b>
<i>759</i>&nbsp;				}
<i>760</i>&nbsp;			}
<b class="nc"><i>761</i>&nbsp;		}</b>
<i>762</i>&nbsp;
<i>763</i>&nbsp;		// return a status only if at least one cacheable matched
<b class="nc"><i>764</i>&nbsp;		if (atLeastOne) {</b>
<b class="nc"><i>765</i>&nbsp;			return new CacheStatus(cUpdates, updateRequired, valueWrapper);</b>
<i>766</i>&nbsp;		}
<i>767</i>&nbsp;
<b class="nc"><i>768</i>&nbsp;		return null;</b>
<i>769</i>&nbsp;	}
<i>770</i>&nbsp;
<i>771</i>&nbsp;	protected Map&lt;CacheOperationContext, Object&gt; inspectCacheUpdates(Collection&lt;CacheOperationContext&gt; updates) {
<i>772</i>&nbsp;
<b class="nc"><i>773</i>&nbsp;		Map&lt;CacheOperationContext, Object&gt; cUpdates = new LinkedHashMap&lt;CacheOperationContext, Object&gt;(updates.size());</b>
<b class="nc"><i>774</i>&nbsp;		if (updates.isEmpty()) {</b>
<b class="nc"><i>775</i>&nbsp;			return cUpdates;</b>
<i>776</i>&nbsp;		}
<i>777</i>&nbsp;
<b class="nc"><i>778</i>&nbsp;		boolean trace = log.isTraceEnabled();</b>
<i>779</i>&nbsp;
<b class="nc"><i>780</i>&nbsp;		for (CacheOperationContext context : updates) {</b>
<b class="nc"><i>781</i>&nbsp;			if (context.isConditionPassing()) {</b>
<i>782</i>&nbsp;
<b class="nc"><i>783</i>&nbsp;				Object key = context.generateKey();</b>
<i>784</i>&nbsp;
<b class="nc"><i>785</i>&nbsp;				if (trace) {</b>
<b class="nc"><i>786</i>&nbsp;					log.trace(&quot;Computed cache key {} for operation {}&quot;,</b>
<i>787</i>&nbsp;							new Object[] { key, context.operation });
<i>788</i>&nbsp;				}
<b class="nc"><i>789</i>&nbsp;				if (key == null) {</b>
<b class="nc"><i>790</i>&nbsp;					throw new IllegalArgumentException(</b>
<i>791</i>&nbsp;							&quot;Null key returned for cache operation (maybe you are using named params on classes without debug info?) &quot; +
<i>792</i>&nbsp;									context.operation);
<i>793</i>&nbsp;				}
<i>794</i>&nbsp;
<i>795</i>&nbsp;				// add op/key (in case an update is discovered later on)
<b class="nc"><i>796</i>&nbsp;				cUpdates.put(context, key);</b>
<b class="nc"><i>797</i>&nbsp;			}</b>
<i>798</i>&nbsp;			else {
<b class="nc"><i>799</i>&nbsp;				if (trace) {</b>
<b class="nc"><i>800</i>&nbsp;					log.trace(&quot;Cache condition failed on method {} for operation {}&quot;,</b>
<i>801</i>&nbsp;							new Object[] { context.method, context.operation} );
<i>802</i>&nbsp;				}
<i>803</i>&nbsp;			}
<b class="nc"><i>804</i>&nbsp;		}</b>
<i>805</i>&nbsp;
<b class="nc"><i>806</i>&nbsp;		return cUpdates;</b>
<i>807</i>&nbsp;	}
<i>808</i>&nbsp;
<i>809</i>&nbsp;	/**
<i>810</i>&nbsp;	 * Assembles a response from a cached page include. These responses are never
<i>811</i>&nbsp;	 * gzipped The content length should not be set in the response, because it
<i>812</i>&nbsp;	 * is a fragment of a page. Don&#39;t write any headers at all.
<i>813</i>&nbsp;	 */
<i>814</i>&nbsp;	protected void writeResponse(final HttpServletResponse response, final PageInfo pageInfo) throws IOException {
<b class="nc"><i>815</i>&nbsp;		byte[] cachedPage = pageInfo.getUngzippedBody();</b>
<b class="nc"><i>816</i>&nbsp;		String page = new String(cachedPage, response.getCharacterEncoding());</b>
<i>817</i>&nbsp;
<b class="nc"><i>818</i>&nbsp;		String implementationVendor = response.getClass().getPackage().getImplementationVendor();</b>
<b class="nc"><i>819</i>&nbsp;		if (implementationVendor != null &amp;&amp; implementationVendor.equals(&quot;\&quot;Evermind\&quot;&quot;)) {</b>
<b class="nc"><i>820</i>&nbsp;			response.getOutputStream().print(page);</b>
<i>821</i>&nbsp;		}
<i>822</i>&nbsp;		else {
<b class="nc"><i>823</i>&nbsp;			response.getWriter().write(page);</b>
<i>824</i>&nbsp;		}
<i>825</i>&nbsp;	}
<i>826</i>&nbsp;
<i>827</i>&nbsp;	protected void update(Collection&lt;Cache&gt; caches, PageInfo pageInfo, CacheStatus cacheStatus, String key) {
<b class="nc"><i>828</i>&nbsp;		ValueWrapper element = cacheStatus == null ? null : cacheStatus.valueWrapper;</b>
<b class="nc"><i>829</i>&nbsp;		Object maxAge = pageInfo.getCacheDirectives().get(&quot;max-age&quot;);</b>
<b class="nc"><i>830</i>&nbsp;		int timeToLive = (maxAge instanceof Integer) ? ((Integer)maxAge) : (int)pageInfo.getTimeToLiveSeconds();</b>
<b class="nc"><i>831</i>&nbsp;		for (Cache cache : caches) {</b>
<b class="nc"><i>832</i>&nbsp;			log.debug(&quot;Response ok. Adding to cache {} with key {} and ttl {}&quot;,</b>
<i>833</i>&nbsp;					new Object[] { cache.getName(), key, getTimeToLive(element) });
<b class="nc"><i>834</i>&nbsp;			put(cache, key, pageInfo, timeToLive);</b>
<b class="nc"><i>835</i>&nbsp;		}</b>
<i>836</i>&nbsp;	}
<i>837</i>&nbsp;
<i>838</i>&nbsp;	protected Object lookupController(Class&lt;?&gt; controllerClass) {
<b class="nc"><i>839</i>&nbsp;		if (controllerClass == null) {</b>
<b class="nc"><i>840</i>&nbsp;			return null;</b>
<i>841</i>&nbsp;		}
<b class="nc"><i>842</i>&nbsp;		return getBean(controllerClass.getName());</b>
<i>843</i>&nbsp;	}
<i>844</i>&nbsp;
<i>845</i>&nbsp;	/**
<i>846</i>&nbsp;	 * Dependency injection for GrailsAnnotationCacheOperationSource.
<i>847</i>&nbsp;	 * @param source
<i>848</i>&nbsp;	 */
<i>849</i>&nbsp;	public void setCacheOperationSource(GrailsAnnotationCacheOperationSource source) {
<b class="nc"><i>850</i>&nbsp;		cacheOperationSource = source;</b>
<i>851</i>&nbsp;	}
<i>852</i>&nbsp;
<i>853</i>&nbsp;	/**
<i>854</i>&nbsp;	 * Dependency injection for ExpressionEvaluator.
<i>855</i>&nbsp;	 * @param source
<i>856</i>&nbsp;	 */
<i>857</i>&nbsp;	public void setExpressionEvaluator(ExpressionEvaluator evaluator) {
<b class="nc"><i>858</i>&nbsp;		expressionEvaluator = evaluator;</b>
<i>859</i>&nbsp;	}
<i>860</i>&nbsp;
<i>861</i>&nbsp;	/**
<i>862</i>&nbsp;	 * Dependency injection for WebKeyGenerator.
<i>863</i>&nbsp;	 * @param source
<i>864</i>&nbsp;	 */
<i>865</i>&nbsp;	public void setKeyGenerator(WebKeyGenerator generator) {
<b class="nc"><i>866</i>&nbsp;		keyGenerator = generator;</b>
<i>867</i>&nbsp;	}
<i>868</i>&nbsp;
<i>869</i>&nbsp;	@Override
<i>870</i>&nbsp;	public void afterPropertiesSet() throws ServletException {
<b class="nc"><i>871</i>&nbsp;		super.afterPropertiesSet();</b>
<b class="nc"><i>872</i>&nbsp;		Assert.notNull(cacheOperationSource, &quot;cacheOperationSource is required&quot;);</b>
<b class="nc"><i>873</i>&nbsp;		Assert.notNull(expressionEvaluator, &quot;expressionEvaluator is required&quot;);</b>
<b class="nc"><i>874</i>&nbsp;		Assert.notNull(keyGenerator, &quot;keyGenerator is required&quot;);</b>
<i>875</i>&nbsp;	}
<i>876</i>&nbsp;
<i>877</i>&nbsp;	public static class CacheStatus {
<i>878</i>&nbsp;		// caches/key
<i>879</i>&nbsp;		protected final Map&lt;CacheOperationContext, Object&gt; updates;
<i>880</i>&nbsp;		protected final boolean updateRequired;
<i>881</i>&nbsp;		protected final ValueWrapper valueWrapper;
<i>882</i>&nbsp;
<b class="nc"><i>883</i>&nbsp;		protected CacheStatus(Map&lt;CacheOperationContext, Object&gt; updates, boolean updateRequired, ValueWrapper valueWrapper) {</b>
<b class="nc"><i>884</i>&nbsp;			this.updates = updates;</b>
<b class="nc"><i>885</i>&nbsp;			this.updateRequired = updateRequired;</b>
<b class="nc"><i>886</i>&nbsp;			this.valueWrapper = valueWrapper;</b>
<i>887</i>&nbsp;		}
<i>888</i>&nbsp;	}
<i>889</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2015-07-12 14:09</div>
</div>
</body>
</html>
